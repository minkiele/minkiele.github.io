import { Camera, PerspectiveCamera, Scene, WebGLRenderer } from 'three';

abstract class ThreeAnimation<C extends Camera> {
  /**
   * Rotation utilities
   */
  public static readonly P2 = 2 * Math.PI;

  public static degToRad(deg: number): number {
    return (deg * Math.PI) / 180;
  }
  public static radToDeg(rad: number): number {
    return (rad * 180) / Math.PI;
  }

  public static getNormalizedSphericAngle(angle: number): number {
    return ((angle % ThreeAnimation.P2) + ThreeAnimation.P2) % ThreeAnimation.P2;
  }

  public static limitNumericValue(min: number, max: number, value: number): number {
    return Math.min(max, Math.max(min, value));
  }

  private scene = new Scene();
  private renderer = new WebGLRenderer();
  private camera: C;
  private isRunningAnimation = false;
  public constructor(private container: HTMLElement) {
    this.camera = this.createCamera();
    this.update();
  }
  /**
   * Use this method to setup the camera
   */
  protected abstract createCamera(): C;
  /**
   * This method is called to update the camera detail
   * Every time the update method is called
   * @param camera The current camera
   */
  protected abstract updateCamera(camera: C): void;

  /**
   * Setup canvas pre mount
   * @param canvas The canvas generated by ThreeJS
   */
  protected setupCanvas(canvas: HTMLCanvasElement): void {}
  /**
   * Teardown canvas logic pre-unmount
   * @param canvas The canvas generated by ThreeJS
   */
  protected teardownCanvas(canvas: HTMLCanvasElement): void {}

  /**
   * Setup the scene and mount the canvas inside the container
   */
  public mount() {
    this.setupScene(this.scene, this.camera);
    this.setupCanvas(this.renderer.domElement);
    this.container.appendChild(this.renderer.domElement);
  }

  /**
   * Stop animation if running and remove the canvas from the container
   */
  public unmount() {
    this.stop();
    this.teardownCanvas(this.renderer.domElement);
    this.container.removeChild(this.renderer.domElement);
  }

  /**
   * Start an animation
   */
  public start() {
    if (!this.isRunningAnimation) {
      this.update();
      this.isRunningAnimation = true;
      this.runAnimation(0);
    }
  }

  /**
   * Stop the animation
   */
  public stop() {
    this.isRunningAnimation = false;
  }

  /**
   * Update renderer size and optionally the camera setting (Adjust camera aspect ratio on resize for example)
   */
  public update() {
    this.updateRenderer();
    this.updateCamera(this.camera);
  }

  /**
   * Utility method to get container sizes
   * @returns an object with `width` and `height` properties
   */
  protected getContainerSize(): Pick<DOMRect, 'width' | 'height'> {
    const { width, height } = this.container.getBoundingClientRect();
    return { width, height };
  }

  /**
   * Update the renderer size to match the size of the container
   */
  private updateRenderer() {
    const { width: newContainerWidth, height: newContainerHeight } = this.getContainerSize();
    this.renderer.setSize(newContainerWidth, newContainerHeight);
  }

  /**
   * Implement this method to setup the scene that will be rendered
   * @param scene The Scene object
   * @param camera The Camera object
   */
  protected abstract setupScene(scene: Scene, camera: C): void;

  /**
   * Every frame the animation is running it will call this function to update
   * scene data
   * @param time Timestamp from window.requestAnimationFrame
   * @param props An object with the current Scene and Camera objects
   */
  protected abstract animate(time: DOMHighResTimeStamp, props: { scene: Scene; camera: C; canvas: HTMLCanvasElement }): void;

  private applyAnimationAndRenderFrame(time: DOMHighResTimeStamp) {
    this.animate(time, { scene: this.scene, camera: this.camera, canvas: this.renderer.domElement });
    this.renderer.render(this.scene, this.camera);
  }

  private runAnimation(time: DOMHighResTimeStamp) {
    if (this.isRunningAnimation) {
      window.requestAnimationFrame(this.runAnimation.bind(this));
      this.applyAnimationAndRenderFrame(time);
    }
  }

  /**
   * Render a single frame instead of starting an animation
   */
  public renderFrame() {
    this.update();
    this.applyAnimationAndRenderFrame(0);
  }

  public addContainerListener(...params: Parameters<InstanceType<typeof Element>['addEventListener']>) {
    this.container.addEventListener(...params);
  }

  public removeContainerListener(...params: Parameters<InstanceType<typeof Element>['removeEventListener']>) {
    this.container.removeEventListener(...params);
  }
}

export abstract class ThreeAnimationWithPerspectiveCamera extends ThreeAnimation<PerspectiveCamera> {
  protected updateCamera(camera: PerspectiveCamera): void {
    const { width: newContainerWidth, height: newContainerHeight } = this.getContainerSize();
    camera.aspect = newContainerWidth / newContainerHeight;
    camera.updateProjectionMatrix();
  }
}

export interface MovementDirection {
  x: number;
  y: number;
  z: number;
}

export class MouseDragger {
  private isMouseDown = false;
  private previousMovement: MovementDirection | undefined;
  constructor(private element: HTMLElement, private dragCallback: (direction: MovementDirection) => void) {
    this.element.addEventListener('mousedown', this.onMouseDown);
    this.element.addEventListener('mouseup', this.onMouseUp);
    this.element.addEventListener('mousemove', this.onMouseMove);
    this.element.addEventListener('mouseleave', this.onMouseUp);
    this.element.addEventListener('wheel', this.onMouseWheel);
  }
  private onMouseDownImpl(evt: MouseEvent) {
    evt.preventDefault();
    this.previousMovement = undefined;
    this.isMouseDown = true;
  }
  private onMouseDown = this.onMouseDownImpl.bind(this);
  private onMouseUpImpl(evt: MouseEvent) {
    evt.preventDefault();
    this.isMouseDown = false;
    this.previousMovement = undefined;
  }
  private onMouseUp = this.onMouseUpImpl.bind(this);
  private onMouseMoveImpl(evt: MouseEvent) {
    evt.preventDefault();
    if (this.isMouseDown) {
      if (this.previousMovement != null) {
        this.dragCallback({
          x: evt.clientX - this.previousMovement.x,
          // Since in ThreeJS Y axis grows upward flip sign
          // because browser Y axis grows downward
          y: this.previousMovement.y - evt.clientY,
          z: 0,
        });
      }
      this.previousMovement = { x: evt.clientX, y: evt.clientY, z: 0 };
    }
  }
  private onMouseMove = this.onMouseMoveImpl.bind(this);

  private onMouseWheelImpl(evt: WheelEvent) {
    evt.preventDefault();
    if (this.previousMovement != null) {
      this.dragCallback({
        x: this.previousMovement.x,
        y: this.previousMovement.y,
        z: evt.deltaY,
      });
    }
    this.previousMovement = { x: this.previousMovement?.x ?? 0, y: this.previousMovement?.y ?? 0, z: evt.deltaY };
  }
  private onMouseWheel = this.onMouseWheelImpl.bind(this);
  public teardown() {
    this.element.removeEventListener('mousedown', this.onMouseDown);
    this.element.removeEventListener('mouseup', this.onMouseUp);
    this.element.removeEventListener('mousemove', this.onMouseMove);
    this.element.removeEventListener('mouseleave', this.onMouseUp);
    this.element.removeEventListener('wheel', this.onMouseWheel);
  }
}

export class KeyboardPresser {
  private key: string | undefined;
  private timeStamp: number | undefined;
  constructor(private element: HTMLElement, private callback: (key: string, deltaMillis: number, preventDefault: () => void) => void) {
    this.element.addEventListener('keydown', this.onKeyDown);
    this.element.addEventListener('keyup', this.onKeyUp);
  }

  private onKeyDownImpl(evt: KeyboardEvent) {
    if (this.key !== evt.key) {
      this.timeStamp = undefined;
    }
    this.callback(evt.key, this.timeStamp == null ? 0 : evt.timeStamp - this.timeStamp, () => evt.preventDefault());
    if (evt.defaultPrevented) {
      this.key = evt.key;
      this.timeStamp = evt.timeStamp;
    }
  }
  private onKeyDown = this.onKeyDownImpl.bind(this);

  private onKeyUpImpl() {
    this.key = undefined;
    this.timeStamp = undefined;
  }
  private onKeyUp = this.onKeyUpImpl.bind(this);

  public teardown() {
    this.element.removeEventListener('keydown', this.onKeyDown);
    this.element.removeEventListener('keyup', this.onKeyUp);
  }
}

export default ThreeAnimation;
