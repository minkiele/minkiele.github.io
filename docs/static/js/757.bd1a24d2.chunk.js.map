{"version":3,"file":"static/js/757.bd1a24d2.chunk.js","mappings":"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","sources":["lib/ubermath.ts","apps/Factorizer/Factorizer.utils.ts","apps/Factorizer/Factorizer.tsx","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["export namespace UberMath {\r\n    export type SumTerm = (i: number, start: number, end: number) => number;\r\n    export function sum(start: number, end: number, sumTerm: SumTerm): number {\r\n        let sum: number = 0;\r\n        for (let i = start; i <= end; i += 1) {\r\n            sum += sumTerm(i, start, end);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    export function getPrimesUpTo(limit: number): Array<number> {\r\n\r\n        const primes: Array<number> = [];\r\n\r\n        /**\r\n         * Optimize: start from 3 and consider only odd numbers. We know\r\n         */\r\n        for (let i = 3; i <= limit; i += 2) {\r\n            let notPrime = false;\r\n            let upperLimit = i;\r\n            // console.log('Testing %d', i);\r\n            for (let j = 0; !notPrime && j < primes.length && primes[j] < upperLimit; j += 1) {\r\n                const rem: number = i % primes[j];\r\n                if (rem === 0) {\r\n                    notPrime = true;\r\n                } else {\r\n                    upperLimit = (i - rem) / primes[j];\r\n                    // console.log('Tested %d with %d, lowering upper limit down to %d', i, primes[j], upperLimit);\r\n                }\r\n            }\r\n            if (!notPrime) {\r\n                primes.push(i);\r\n                // console.log('Found prime %d', i);\r\n            }\r\n        }\r\n\r\n        if (limit >= 2) {\r\n            primes.unshift(2);\r\n        }\r\n\r\n        return primes;\r\n    }\r\n\r\n    export function getPrimesRateUpTo(limit: number): number {\r\n        return getPrimesUpTo(limit).length / limit * 100;\r\n    }\r\n\r\n    export function isPrime(input: number): boolean {\r\n        let upperLimit: number = input;\r\n        if (input < 2) {\r\n            return false;\r\n        }\r\n        if (input % 2 === 0) {\r\n            return false;\r\n        }\r\n        for (let i = 3; i < upperLimit; i += 2) {\r\n            const rem: number = input % i;\r\n            if (rem === 0) {\r\n                return false;\r\n            } else {\r\n                upperLimit = (input - rem) / i;\r\n                // console.log('Set upper limit to %d', upperLimit);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    export function factorize(input: number): Array<number> {\r\n        let factors: Array<number> = [];\r\n        let upperLimit: number = input;\r\n        let i: number = 2;\r\n        let current: number = input;\r\n        while (i < upperLimit) {\r\n            // console.log('Testing %d on an upper limit of %d', i, upperLimit);\r\n            const rem = current % i;\r\n            if (rem === 0) {\r\n                factors.push(i);\r\n                current /= i;\r\n                upperLimit = current;\r\n                // console.log('Found %d, setting current to %d', i, current);\r\n            } else {\r\n                upperLimit = (current - rem) / i;\r\n                i += (i === 2 ? 1 : 2);\r\n            }\r\n        }\r\n        // Current is already the largest prime.\r\n        // console.log('Adding back largest prime number found %d', current);\r\n        if (i >= upperLimit) {\r\n            factors.push(current);\r\n        }\r\n        return factors;\r\n    }\r\n\r\n    function sortNumbers (a: number, b: number): number {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * This is a function to progressively factorize an array of numbers\r\n     * I believe I wrote this in 2019, but while toying around with it in 2022 I found\r\n     * there is a little problem: for certain sets the it will fail to find 3 as a prime\r\n     * thus setting 9 as prime. Bootstrapping the primes array including 3 seems to solve the problem.\r\n     * @param inputs An array of natural numbers\r\n     * @param primes An array of prime numbers to speed up factorization\r\n     * @returns An array of arrays\r\n     */\r\n    export function factorizeInputs(inputs: Array<number>, primes: Array<number> = [2, 3]): Array<Array<number>> {\r\n\r\n        let largestPrime = Math.max(...primes);\r\n\r\n        const allFactors: Array<{input: number, factors: Array<number>}> = [];\r\n\r\n        const sortedInputs = Array.from(inputs).sort(sortNumbers);\r\n\r\n        for (const input of sortedInputs) {\r\n            console.log('Starting factorization of %d', input);\r\n            let factors: Array<number> = [];\r\n            let upperLimit: number = input;\r\n            let i = 2;\r\n            let current: number = input;\r\n\r\n            let currentPrimeIndex = 0;\r\n            while (currentPrimeIndex < primes.length && i < upperLimit) {\r\n                i = primes[currentPrimeIndex];\r\n                console.log('Testing found prime %d on an upper limit of %d', i, upperLimit);\r\n                const rem = current % i;\r\n                if (rem === 0) {\r\n                    factors.push(i);\r\n                    current /= i;\r\n                    upperLimit = current;\r\n                } else {\r\n                    upperLimit = (current - rem) / i;\r\n                    currentPrimeIndex += 1;\r\n                }\r\n            }\r\n\r\n            while (i < upperLimit) {\r\n                console.log('Testing %d on an upper limit of %d', i, upperLimit);\r\n                const rem = current % i;\r\n                if (rem === 0) {\r\n                    factors.push(i);\r\n                    if (i > largestPrime) {\r\n                        primes.push(i);\r\n                        largestPrime = i;\r\n                        console.log('Adding %d as largest prime', largestPrime);\r\n                    }\r\n                    current /= i;\r\n                    upperLimit = current;\r\n                    console.log('Found %d, setting current to %d', i, current);\r\n                } else {\r\n                    upperLimit = (current - rem) / i;\r\n                    i += (i === 2 ? 1 : 2);\r\n                }\r\n            }\r\n            // Current is already the largest prime.\r\n            console.log('Adding back largest prime number found %d', current);\r\n            if (i >= upperLimit) {\r\n                factors.push(current);\r\n                if (i > largestPrime) {\r\n                    primes.push(i);\r\n                    largestPrime = i;\r\n                }\r\n            }\r\n            allFactors.push({input, factors});\r\n        }\r\n        return allFactors.sort(({input: a}, {input: b}) => sortNumbers(a, b)).map(({factors}) => factors);\r\n    }\r\n\r\n    export function range(length: number, start = 0, step = 1): Array<number> {\r\n        const output = [];\r\n        for(let i = 0; i < length; i += 1) {\r\n            output.push(i * step + start);\r\n        }\r\n        return output;\r\n    }\r\n\r\n}\r\n","import { countBy, identity, pipe, toPairs } from \"ramda\";\nimport { UberMath } from \"../../lib/ubermath\";\n\nexport const getGroupedFactors = pipe(UberMath.factorize, countBy(identity), toPairs);\n","import {\n  ChangeEventHandler,\n  Fragment,\n  FunctionComponent,\n  useMemo,\n  useState,\n} from \"react\";\nimport { getGroupedFactors } from \"./Factorizer.utils\";\n\nconst Factorizer: FunctionComponent = () => {\n  const [input, setInput] = useState<number>(2);\n  const groupedFactors = useMemo(\n    () => getGroupedFactors(input) as Array<[string, number]>,\n    [input]\n  );\n  const handleInput: ChangeEventHandler<HTMLInputElement> = (evt) => {\n    const parsedInput = parseInt(evt.target.value);\n    setInput(isNaN(parsedInput) || parsedInput < 2 ? 2 : parsedInput);\n  };\n  return (\n    <div>\n      <p>A little function that factorizes a natural input &gt; than 1</p>\n      <fieldset>\n        <legend>Factorize</legend>\n        <label htmlFor=\"input\">Input number: </label>\n        <input\n          id=\"input\"\n          name=\"input\"\n          type=\"number\"\n          value={input}\n          onChange={handleInput}\n        />\n      </fieldset>\n      <p>\n        {input} ={\" \"}\n        {groupedFactors.map(([factor, exp], index) => (\n          <Fragment key={`${factor}-${exp}`}>\n            {index > 0 && <>&times;</>}\n            {factor}\n            {exp > 1 && <sup>{exp}</sup>}\n          </Fragment>\n        ))}\n      </p>\n    </div>\n  );\n};\n\nexport default Factorizer;\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["getPrimesUpTo","limit","primes","i","notPrime","upperLimit","j","length","rem","push","unshift","sortNumbers","a","b","start","end","sumTerm","sum","input","factors","current","inputs","largestPrime","Math","max","allFactors","sortedInputs","Array","from","sort","console","log","currentPrimeIndex","map","step","output","UberMath","getGroupedFactors","pipe","factorize","countBy","identity","toPairs","useState","setInput","groupedFactors","useMemo","htmlFor","id","name","type","value","onChange","evt","parsedInput","parseInt","target","isNaN","index","factor","exp","Fragment","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","isArray","F","s","n","done","e","_e","f","TypeError","err","normalCompletion","didErr","call","next","_e2"],"sourceRoot":""}